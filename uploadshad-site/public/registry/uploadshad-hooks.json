{
  "name": "uploadshad-hooks",
  "type": "registry:hook",
  "files": [
    {
      "path": "component/uploadshad/hooks/index.ts",
      "content": "import { useControllableState } from \"./controlled-state\";\r\nimport { handleUploadFile, handleRejectedFiles } from \"./controller-layer\";\r\nimport {\r\n  FilesContext,\r\n  FilesContextProvider,\r\n  FilesContextType,\r\n  useFilesContext,\r\n} from \"./files-context\";\r\n\r\nexport {\r\n  FilesContext,\r\n  useFilesContext,\r\n  handleUploadFile,\r\n  handleRejectedFiles,\r\n  useControllableState,\r\n  FilesContextProvider,\r\n  type FilesContextType,\r\n};\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/hooks/index.ts"
    },
    {
      "path": "component/uploadshad/hooks/files-context.tsx",
      "content": "import { toast } from \"sonner\";\r\nimport { reorder } from \"@/registry/component/uploadshad/utils\";\r\nimport React, { useState, createContext, useContext, useCallback } from \"react\";\r\nimport { handleDeleteFile, handleFetchSignedURL, handleUploadFile } from \"./controller-layer\";\r\n\r\nexport type FilesContextType = {\r\n  /**\r\n   * Array of uploaded images\r\n   */\r\n  files: string[];\r\n  handleDelete: (deletedFile: string) => Promise<boolean>;\r\n  handleInput: (files: File[]) => Promise<void>;\r\n  handleReOrder: (source: number, destination: number) => void;\r\n};\r\n\r\nexport const FilesContext = createContext<FilesContextType | undefined>(undefined);\r\n\r\nexport function useFilesContext() {\r\n  const context = useContext(FilesContext);\r\n  if (!context) throw new Error(\"useFilesContext must be used within a FilesContextProvider\");\r\n  return context;\r\n}\r\n\r\nexport const FilesContextProvider: React.FC<{\r\n  folderId?: string;\r\n  defaultValues?: string[];\r\n  children: React.ReactNode;\r\n  onChange?: (files: string[]) => void;\r\n  metadata?: Record<string, string> | undefined;\r\n}> = ({ children, defaultValues, metadata, folderId, onChange }) => {\r\n  const [files, setFiles] = useState<string[]>(defaultValues || []);\r\n\r\n  const handleStateChange = useCallback(\r\n    (newFiles: string[]) => {\r\n      setFiles(newFiles);\r\n      if (onChange) onChange(newFiles);\r\n    },\r\n    [setFiles, onChange]\r\n  );\r\n\r\n  // Handles (Presign & Uploading to S3) & Updating Files state\r\n  const handleInput = async (inputFiles: File[]) => {\r\n    const urls = await Promise.all(\r\n      inputFiles.map(async (file) => {\r\n        // Get Signed URL & Uploading\r\n        const signedUrl = await handleFetchSignedURL(file, folderId, metadata);\r\n        const fileUploadResponse = await handleUploadFile(signedUrl, file);\r\n\r\n        if (fileUploadResponse.failure || !fileUploadResponse.url) {\r\n          toast.error(`Failed to upload ${file.name}`, {\r\n            description: \"Please try uploading your image again.\",\r\n            duration: 5000,\r\n          }); // Do something with error\r\n          return \"\";\r\n        }\r\n\r\n        // Update File State\r\n        return fileUploadResponse.url.split(\"?\")[0];\r\n      })\r\n    ).then((urls) => urls.filter((url) => url != \"\"));\r\n\r\n    handleStateChange([...files, ...urls]);\r\n    console.log(\"UploadShad Tracking: Controller Input Handler - File added to State\");\r\n  };\r\n  // Handles deleting file from state\r\n  const handleDelete = useCallback(\r\n    async (deletedFile: string) => {\r\n      // Delete File in Cloud provider (S3)\r\n      const response = await handleDeleteFile(deletedFile);\r\n      console.log(\"UploadShad Tracking: Controller Delete Handler - Response\", response);\r\n\r\n      if (!response) {\r\n        return false;\r\n      }\r\n\r\n      // Update State\r\n      const newFiles = files.filter((file) => file != deletedFile);\r\n      handleStateChange(newFiles);\r\n      console.log(\r\n        \"UploadShad Tracking: Controller Delete Handler - File removed from State\",\r\n        deletedFile\r\n      );\r\n\r\n      return true;\r\n    },\r\n    [files, handleStateChange]\r\n  );\r\n\r\n  // Handles drag End event to reorder files\r\n  const handleDragEnd = useCallback(\r\n    (source: number, destination: number) => {\r\n      const newImages = reorder(files || [], source, destination);\r\n      handleStateChange(newImages);\r\n    },\r\n    [files, handleStateChange]\r\n  );\r\n\r\n  return (\r\n    <FilesContext.Provider\r\n      value={{\r\n        files: files as string[],\r\n        handleInput: handleInput,\r\n        handleDelete: handleDelete,\r\n        handleReOrder: handleDragEnd,\r\n      }}\r\n    >\r\n      {children}\r\n    </FilesContext.Provider>\r\n  );\r\n};\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/hooks/files-context.tsx"
    },
    {
      "path": "component/uploadshad/hooks/controlled-state.ts",
      "content": "import * as React from \"react\";\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\r\n */\r\n\r\ntype UseControllableStateParams<T> = {\r\n  prop?: T | undefined;\r\n  defaultProp?: T | undefined;\r\n  onChange?: (state: T) => void;\r\n};\r\n\r\ntype SetStateFn<T> = (prevState?: T) => T;\r\n\r\nfunction useControllableState<T>({\r\n  prop,\r\n  defaultProp,\r\n  onChange = () => {},\r\n}: UseControllableStateParams<T>) {\r\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({\r\n    defaultProp,\r\n    onChange,\r\n  });\r\n  const isControlled = prop !== undefined;\r\n  const value = isControlled ? prop : uncontrolledProp;\r\n  const handleChange = useCallbackRef(onChange);\r\n\r\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\r\n    (nextValue) => {\r\n      if (isControlled) {\r\n        const setter = nextValue as SetStateFn<T>;\r\n        const value = typeof nextValue === \"function\" ? setter(prop) : nextValue;\r\n        if (value !== prop) handleChange(value as T);\r\n      } else {\r\n        setUncontrolledProp(nextValue);\r\n      }\r\n    },\r\n    [isControlled, prop, setUncontrolledProp, handleChange]\r\n  );\r\n\r\n  return [value, setValue] as const;\r\n}\r\n\r\nfunction useUncontrolledState<T>({\r\n  defaultProp,\r\n  onChange,\r\n}: Omit<UseControllableStateParams<T>, \"prop\">) {\r\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\r\n  const [value] = uncontrolledState;\r\n  const prevValueRef = React.useRef(value);\r\n  const handleChange = useCallbackRef(onChange);\r\n\r\n  React.useEffect(() => {\r\n    if (prevValueRef.current !== value) {\r\n      handleChange(value as T);\r\n      prevValueRef.current = value;\r\n    }\r\n  }, [value, prevValueRef, handleChange]);\r\n\r\n  return uncontrolledState;\r\n}\r\n\r\n/**\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/react/use-callback-ref/src/useCallbackRef.tsx\r\n */\r\n\r\n/**\r\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\r\n * prop or avoid re-executing effects when passed as a dependency\r\n */\r\nfunction useCallbackRef<T extends (...args: never[]) => unknown>(callback: T | undefined): T {\r\n  const callbackRef = React.useRef(callback);\r\n\r\n  React.useEffect(() => {\r\n    callbackRef.current = callback;\r\n  });\r\n\r\n  // https://github.com/facebook/react/issues/19240\r\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\r\n}\r\nexport { useControllableState, useCallbackRef };\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/hooks/controlled-state.ts"
    },
    {
      "path": "component/uploadshad/hooks/controller-layer.ts",
      "content": "\"use client\";\r\n\r\nimport { FileRejection } from \"react-dropzone\";\r\nimport { toast } from \"sonner\";\r\nimport {\r\n  computeSHA256,\r\n  formatBytes,\r\n  getClientVariables,\r\n  FilePayload,\r\n} from \"@/registry/component/uploadshad/utils\";\r\n\r\nconst { NEXT_PUBLIC_HOST_URL } = getClientVariables();\r\n\r\nexport async function handleFetchSignedURL(\r\n  file: File,\r\n  folderId?: string,\r\n  metadata?: Record<string, string>\r\n) {\r\n  // Get PreSign url from API\r\n  const checksum = await computeSHA256(file);\r\n  const payload: FilePayload = {\r\n    type: file.type,\r\n    size: file.size,\r\n    checksum: checksum,\r\n    metadata: metadata,\r\n    folderId: folderId,\r\n  };\r\n\r\n  console.log(\"UploadShad Tracking: PreSigned URL Payload - \", payload);\r\n\r\n  const signedURLResult = await fetch(`${NEXT_PUBLIC_HOST_URL}/api/uploadshad`, {\r\n    method: \"POST\",\r\n    body: JSON.stringify(payload),\r\n  })\r\n    .then((res) => res.json())\r\n    .catch((err) => {\r\n      console.log(\"UploadShad Tracking: Failed to get PreSigned URL - \", err);\r\n      toast.error(`Failed to upload ${file.name}`, {\r\n        description: \"Please try uploading your image again.\",\r\n        duration: 5000,\r\n      });\r\n    });\r\n\r\n  return signedURLResult.signedURL;\r\n}\r\n\r\n// Post File to S3 using PreSign url\r\nexport async function handleUploadFile(signedUrl: string, file: File) {\r\n  try {\r\n    await fetch(signedUrl, {\r\n      method: \"PUT\",\r\n      body: file,\r\n      headers: {\r\n        \"Content-Type\": file.type,\r\n      },\r\n    });\r\n    return { url: signedUrl.split(\"?\")[0] };\r\n  } catch (error) {\r\n    console.log(\"UploadShad Tracking: Failed to Upload File to S3 using PreSigned URL - \", error);\r\n    return { failure: true };\r\n  }\r\n}\r\n\r\n// Post File to S3 using PreSign url\r\nexport async function handleDeleteFile(url: string) {\r\n  try {\r\n    await fetch(`${NEXT_PUBLIC_HOST_URL}/api/uploadshad?url=${url}`, {\r\n      method: \"DELETE\",\r\n    });\r\n    return true;\r\n  } catch (error) {\r\n    console.log(\"UploadShad Tracking: Failed to Delete File in S3 File URL - \", error);\r\n    return false;\r\n  }\r\n}\r\n\r\n// Displays a toast when a file is rejected based on their error reason\r\nexport const handleRejectedFiles = (rejectedFiles: FileRejection[], maxSize: number) =>\r\n  rejectedFiles.length > 0 &&\r\n  rejectedFiles.forEach(({ errors, file }) => {\r\n    errors.forEach((error) => {\r\n      switch (error.code) {\r\n        case \"file-invalid-type\":\r\n          toast.error(`File ${file.name} was rejected.`, {\r\n            description: `${file.type} are not allowed.`,\r\n            duration: 10000,\r\n          });\r\n          break;\r\n        case \"file-too-large\":\r\n          toast.error(`File ${file.name} was rejected.`, {\r\n            description: `Files bigger than ${formatBytes(maxSize)} are not allowed.`,\r\n            duration: 10000,\r\n          });\r\n          break;\r\n        case \"file-too-small\":\r\n          toast.error(`File ${file.name} was rejected.`, {\r\n            description: `Files smaller than ${formatBytes(maxSize)} are not allowed.`,\r\n            duration: 10000,\r\n          });\r\n          break;\r\n        case \"too-many-files\":\r\n          toast.error(`Your files was rejected.`, {\r\n            description: `Too many files were uploaded.`,\r\n            duration: 10000,\r\n          });\r\n          break;\r\n        default:\r\n          toast.error(\"Oops, something happened.\", {\r\n            description: `File ${file.name} was rejected.`,\r\n            duration: 10000,\r\n          });\r\n      }\r\n    });\r\n  });\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/hooks/controller-layer.ts"
    }
  ]
}