{
  "name": "uploadshad-utils",
  "type": "registry:lib",
  "files": [
    {
      "path": "component/uploadshad/utils/index.ts",
      "content": "import { S3Service, FilePayload, FilePayloadSchema } from \"./s3service\";\r\nimport { getClientVariables, getServerVariables } from \"./secrets\";\r\nimport {\r\n  formatBytes,\r\n  getDownloadUrl,\r\n  formatFileSize,\r\n  computeSHA256,\r\n  reorder,\r\n  composeEventHandlers,\r\n} from \"./utils\";\r\n\r\nexport {\r\n  S3Service,\r\n  formatBytes,\r\n  reorder,\r\n  getClientVariables,\r\n  getServerVariables,\r\n  computeSHA256,\r\n  FilePayloadSchema,\r\n  type FilePayload,\r\n};\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/utils/index.ts"
    },
    {
      "path": "component/uploadshad/utils/s3service.ts",
      "content": "import { z } from \"zod\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { getClientVariables, getServerVariables } from \"./secrets\";\r\nimport { getSignedUrl } from \"@aws-sdk/s3-request-presigner\";\r\nimport { S3Client, PutObjectCommand, DeleteObjectCommand } from \"@aws-sdk/client-s3\";\r\n\r\nexport class S3Service {\r\n  private s3Client: S3Client;\r\n  private BaseUrl: string;\r\n  private BucketName: string;\r\n  private ProductionFolder: string;\r\n\r\n  constructor() {\r\n    const {\r\n      AWS_BUCKET_REGION,\r\n      AWS_BUCKET_ACCESS_KEY,\r\n      AWS_BUCKET_SECRET_ACCESS_KEY,\r\n      AWS_BUCKET_PRODUCTION_FOLDER,\r\n      AWS_BUCKET_NAME,\r\n    } = getServerVariables();\r\n    const { NEXT_PUBLIC_AWS_BASE_URL } = getClientVariables();\r\n    this.ProductionFolder = AWS_BUCKET_PRODUCTION_FOLDER;\r\n    this.BaseUrl = NEXT_PUBLIC_AWS_BASE_URL;\r\n    this.BucketName = AWS_BUCKET_NAME;\r\n\r\n    this.s3Client = new S3Client({\r\n      region: AWS_BUCKET_REGION,\r\n      credentials: {\r\n        accessKeyId: AWS_BUCKET_ACCESS_KEY,\r\n        secretAccessKey: AWS_BUCKET_SECRET_ACCESS_KEY,\r\n      },\r\n    });\r\n  }\r\n\r\n  generateKey(folderId?: string) {\r\n    return `${this.ProductionFolder}/${folderId && folderId + \"/\"}${uuidv4()}`;\r\n  }\r\n\r\n  getKeyfromUrl(url: string) {\r\n    return url.split(`${this.BaseUrl}/`)[1];\r\n  }\r\n\r\n  async getSignedURL(\r\n    { type, checksum, size, tag, metadata, folderId }: FilePayload,\r\n    { acceptedTypes, maxFileSize }: AWSOptions\r\n  ) {\r\n    // Validate request\r\n    if (!acceptedTypes.includes(type)) {\r\n      return { failure: \"Not valid type\" };\r\n    }\r\n\r\n    if (size > maxFileSize) {\r\n      return { failure: \"File too large.\" };\r\n    }\r\n\r\n    const key = this.generateKey(folderId);\r\n\r\n    const command = new PutObjectCommand({\r\n      Key: key,\r\n      Tagging: tag,\r\n      ContentType: type,\r\n      Metadata: metadata,\r\n      ContentLength: size,\r\n      ChecksumSHA256: checksum,\r\n      Bucket: this.BucketName,\r\n    });\r\n\r\n    const url = await getSignedUrl(this.s3Client, command, { expiresIn: 3600 });\r\n\r\n    return { signedURL: url };\r\n  }\r\n\r\n  async deleteFile(url: string) {\r\n    const command = new DeleteObjectCommand({\r\n      Bucket: this.BucketName,\r\n      Key: this.getKeyfromUrl(url),\r\n    });\r\n\r\n    try {\r\n      await this.s3Client.send(command);\r\n      // console.log(\"AWS Delete Response: \", response);\r\n      return { success: true };\r\n    } catch (err) {\r\n      return { failure: err };\r\n    }\r\n  }\r\n\r\n  async deleteFiles(files: string[]) {\r\n    Promise.all(\r\n      files.map((file, index) => {\r\n        this.deleteFile(file);\r\n      })\r\n    );\r\n  }\r\n}\r\n\r\nexport const FilePayloadSchema = z.object({\r\n  type: z.string(),\r\n  size: z.number(),\r\n  checksum: z.string(),\r\n  /**\r\n   * Example: `<tagId>=<tagValue>`\r\n   */\r\n  tag: z.string().optional(),\r\n  metadata: z.record(z.string()).optional(),\r\n  folderId: z.string().optional(),\r\n});\r\n\r\nexport interface AWSOptions {\r\n  acceptedTypes: string[];\r\n  maxFileSize: number;\r\n}\r\n\r\nexport type FilePayload = z.infer<typeof FilePayloadSchema>;\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/utils/s3service.ts"
    },
    {
      "path": "component/uploadshad/utils/secrets.ts",
      "content": "import { z } from \"zod\";\r\n\r\nconst AWSVariablesSchema = z.object({\r\n  AWS_BUCKET_NAME: z.string().nonempty(),\r\n  AWS_BUCKET_REGION: z.string().nonempty(),\r\n  AWS_BUCKET_ACCESS_KEY: z.string().nonempty(),\r\n  AWS_BUCKET_PRODUCTION_FOLDER: z.string().nonempty(),\r\n  AWS_BUCKET_SECRET_ACCESS_KEY: z.string().nonempty(),\r\n});\r\nconst clientVariablesSchema = z.object({\r\n  NEXT_PUBLIC_HOST_URL: z.string().nonempty(),\r\n  NEXT_PUBLIC_AWS_BASE_URL: z.string().nonempty(),\r\n});\r\n\r\nconst clientVariables = {\r\n  NEXT_PUBLIC_HOST_URL: process.env.NEXT_PUBLIC_HOST_URL,\r\n  NEXT_PUBLIC_AWS_BASE_URL: process.env.NEXT_PUBLIC_AWS_BASE_URL,\r\n};\r\n\r\nconst AWSVariables = {\r\n  AWS_BUCKET_NAME: process.env.AWS_BUCKET_NAME,\r\n  AWS_BUCKET_REGION: process.env.AWS_BUCKET_REGION,\r\n  AWS_BUCKET_ACCESS_KEY: process.env.AWS_BUCKET_ACCESS_KEY,\r\n  AWS_BUCKET_PRODUCTION_FOLDER: process.env.AWS_BUCKET_PRODUCTION_FOLDER,\r\n  AWS_BUCKET_SECRET_ACCESS_KEY: process.env.AWS_BUCKET_SECRET_ACCESS_KEY,\r\n};\r\n\r\nexport function getClientVariables() {\r\n  if (!clientVariables.NEXT_PUBLIC_HOST_URL) {\r\n    throw new Error(\"UploadShad Error: Missing NEXT_PUBLIC_HOST_URL\");\r\n  } else if (!clientVariables.NEXT_PUBLIC_AWS_BASE_URL) {\r\n    throw new Error(\"UploadShad Error: Missing NEXT_PUBLIC_AWS_BASE_URL\");\r\n  }\r\n\r\n  const safeClientVariables = clientVariablesSchema.safeParse(clientVariables);\r\n  if (!safeClientVariables.success) {\r\n    throw new Error(\"UploadShad Error: Invalid NEXT_PUBLIC env variables\");\r\n  }\r\n\r\n  return safeClientVariables.data;\r\n}\r\n\r\nexport function getServerVariables() {\r\n  if (!AWSVariables.AWS_BUCKET_NAME) {\r\n    throw new Error(\"UploadShad Error: Missing AWS env variable. Ensure AWS_BUCKET_NAME is set\");\r\n  } else if (!AWSVariables.AWS_BUCKET_REGION) {\r\n    throw new Error(\"UploadShad Error: Missing AWS env variable. Ensure AWS_BUCKET_REGION is set\");\r\n  } else if (!AWSVariables.AWS_BUCKET_ACCESS_KEY) {\r\n    throw new Error(\r\n      \"UploadShad Error: Missing AWS env variable. Ensure AWS_BUCKET_ACCESS_KEY is set\"\r\n    );\r\n  } else if (!AWSVariables.AWS_BUCKET_PRODUCTION_FOLDER) {\r\n    throw new Error(\r\n      \"UploadShad Error: Missing AWS env variable. Ensure AWS_BUCKET_PRODUCTION_FOLDER is set\"\r\n    );\r\n  } else if (!AWSVariables.AWS_BUCKET_SECRET_ACCESS_KEY) {\r\n    throw new Error(\r\n      \"UploadShad Error: Missing AWS env variable. Ensure AWS_BUCKET_SECRET_ACCESS_KEY is set\"\r\n    );\r\n  }\r\n\r\n  const safeAWSVariables = AWSVariablesSchema.safeParse(AWSVariables);\r\n  if (!safeAWSVariables.success) {\r\n    throw new Error(\"UploadShad Error: Invalid AWS env variables\");\r\n  }\r\n  return safeAWSVariables.data;\r\n}\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/utils/secrets.ts"
    },
    {
      "path": "component/uploadshad/utils/utils.ts",
      "content": "export function formatBytes(\r\n  bytes: number,\r\n  opts: {\r\n    decimals?: number;\r\n    sizeType?: \"accurate\" | \"normal\";\r\n  } = {}\r\n) {\r\n  const { decimals = 0, sizeType = \"normal\" } = opts;\r\n\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\"];\r\n  const accurateSizes = [\"Bytes\", \"KiB\", \"MiB\", \"GiB\", \"TiB\"];\r\n  if (bytes === 0) return \"0 Byte\";\r\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\r\n  return `${(bytes / Math.pow(1024, i)).toFixed(decimals)} ${\r\n    sizeType === \"accurate\" ? accurateSizes[i] ?? \"Bytest\" : sizes[i] ?? \"Bytes\"\r\n  }`;\r\n}\r\n\r\n/**\r\n * Stole this from the @radix-ui/primitive\r\n * @see https://github.com/radix-ui/primitives/blob/main/packages/core/primitive/src/primitive.tsx\r\n */\r\nexport function composeEventHandlers<E>(\r\n  originalEventHandler?: (event: E) => void,\r\n  ourEventHandler?: (event: E) => void,\r\n  { checkForDefaultPrevented = true } = {}\r\n) {\r\n  return function handleEvent(event: E) {\r\n    originalEventHandler?.(event);\r\n\r\n    if (checkForDefaultPrevented === false || !(event as unknown as Event).defaultPrevented) {\r\n      return ourEventHandler?.(event);\r\n    }\r\n  };\r\n}\r\n/**\r\n * This will add the necessary query param to the url\r\n * to make the browser download the file instead of opening it.\r\n *\r\n * You can also override the name of the file by passing the name param.\r\n */\r\nexport function getDownloadUrl(url: string, name?: string) {\r\n  const urlObj = new URL(url);\r\n  urlObj.searchParams.set(\"download\", name ?? \"true\");\r\n  return urlObj.toString();\r\n}\r\n\r\n/**\r\n * This will format the file size to a human readable format.\r\n *\r\n * @example 1024 => 1 KB\r\n */\r\nexport function formatFileSize(bytes?: number) {\r\n  if (!bytes) {\r\n    return \"0 Bytes\";\r\n  }\r\n  bytes = Number(bytes);\r\n  if (bytes === 0) {\r\n    return \"0 Bytes\";\r\n  }\r\n  const k = 1024;\r\n  const dm = 2;\r\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\r\n}\r\n\r\nexport const computeSHA256 = async (file: File) => {\r\n  const buffer = await file.arrayBuffer();\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\r\n  return hashHex;\r\n};\r\n\r\n// Handles reordering files\r\nexport const reorder = (list: string[], startIndex: number, endIndex: number) => {\r\n  const result = Array.from(list);\r\n  const [removed] = result.splice(startIndex, 1);\r\n  result.splice(endIndex, 0, removed || \"\");\r\n  return result;\r\n};\r\n",
      "type": "registry:component",
      "target": "components/uploadshad/utils/utils.ts"
    }
  ]
}